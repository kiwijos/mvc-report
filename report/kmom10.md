# kmom10
## Inledning

### Förord
När vi gjorde våra kortspel sa jag att det fanns en del saker som jag skulle vilja förbättra om jag fick chansen. Glöm det! För nu blev det ett äventyrsspel. Jag är verkligen en gamer at heart och såg det här som en riktigt rolig utmaning.

Jag började inte förrän efter deadline och har därmed känt att jag har kunnat ta det lugnt och höja ambitionsnivån. Jag har testet olika designalternativ och ägnat extra tid åt att förstå och lösa eventuella utmaningar som har uppstått längs vägen. Men var lugn! Det har blivit många dagar med sol och bad också. (Projektet har inte tagit så lång tid som man kan tro.)


## Krav 1, 2, 3: Webbplats

### Innehåll och utseende
Projektet skulle se helt annorlunda ut, så det kändes bra att dela upp koden så mycket som möjligt. Jag har gjort ett nytt stylesheet och en ny base template för projektsidorna. Bakom finns det nu två entries i assetskatalogen. En för det vi gjort i kursen innan och en för det som bara har med projektet att göra. Jag skapade även en till databas.

Stilen på projektsidorna, och spelet i synnerhet, är retroinspirerad . Den bygger på bara ett fåtal färger och det hela ska se ut som skrivbordet på en gammal dator fast med en modern touch. Navbaren utgörs av ett par skrivbordsikoner och de olika sidorna ser ut som olika fönster. Spelet är helt och hållet textbaserat och använder ett ”pixeltypsnitt” för att ge det en distinkt stil som för tankarna till klassiska äventyrsspel.

### Fokus: Äventyrsspel
Jag har utgått från förslaget på kurssidan. Det finns i huvudsak fyra olika saker man kan göra som spelare: Man kan utforska föremål (”examine”), ta dem och lägga dem i sin ryggsäck (”take”), använda föremålen i sin ryggsäck (”use”), och man kan förflytta sig i de olika vädersträcken (”go”). Alla pussel går ut på att man behöver hitta och använda ett visst föremål på en speciell plats. Ledtrådar får man antingen i rummens beskrivningar eller genom att utforska föremål. En viktig komponent i spelet är loggen. Man kan säga att det är den som spelaren interagerar med. Därför har allting som händer i spelet en textrespons.

Medan jag utvecklade spelet hade jag bara två rum och ett föremål som jag skapade direkt i koden. Det räckte för att jag skulle kunna testa alla interaktioner. När jag väl bytta ut dem mot alla de rum och föremål jag förberett i databasen fungerade spelet fortfarande som det var tänkt. Vilket jag knappt vågat hoppas på. Spelet är ganska lätt. Men det blev fler rum än vad som förslogs. Vilket beror på att jag först trodde att det stod ”Spelet kan var 3-5 rum stort (eller större) ”. När jag väl hade basen på plats var det dessutom enkelt att lägga till flera rum och föremål. Så den biten gick förhållandevis fort för mig.

Huvudmålet har varit att få till en bra struktur enligt förslaget så att det går att lägga till rum och föremål på ett generellt sätt. Kort sagt bygger spelet på att varje rum kan vara anslutet till andra rum och att varje rum kan ha ett eller flera föremål. Föremål i sin tur kan ha en eller flera ”actions” som talar om vad man kan göra med föremålet. Actions kan ha en respons. I nuläget är det bara actions av typen ”use” som har det. Antingen flyttar responsen spelaren till ett nytt rum utan att göra något med det nuvarande rummet, eller så byter det ut spelarens nuvarande rum mot ett nytt och flyttar alla anslutna rum till det nya rummet. Att flytta spelaren till ett nytt rum kan användas om man vill att spelaren inte längre ska kunna gå tillbaka. Ett exempel är när spelet är slut eller när man vill visa att spelaren nått en ny nivå.

Genom att byta ut det rum man är i kan man få det att verka som att rummet uppdateras, exempelvis genom att byta till ett rum där någon detalj är annorlunda eller där det finns ett nytt rum anslutet. Innan jag hade den här lösningen var tanken att de nya rummen skulle vara ”gömda”, tills spelaren använder rätt föremål det vill säga. Med det menas att rummen redan är anslutna, fast de syns inte i texten som spelaren får och de går heller inte att interagera med. Fördelen med det här är att det går lätt att ansluta rum, man behöver bara ”o-gömma” dem. Nackdelen är att det behövs logik på andra ställen som ser till att rummen inte syns så länge de är gömda. Det går heller inte att uppdatera rummet man är i på det här sättet, så för det skulle man behöva en annan lösning.

### Repo och dokumentation
Målet har varit att testa alla projektets kontrollerklasser och modellklasser. Jag har inte gått tillbaka och testat sånt vi gjort innan. Men jag har försökt fixa eventuella fel som dykt upp när jag rättat koden även om det gäller gamla saker. Kollar vi enbart på projektet hamnade kodtäckningen på totalt drygt 90 procent. Vilket jag är helt okej nöjd med. Kollar vi på hela applikationen i Scrutnizer är kodtäckningen nu 52 procent, vilket är en ökning med 25 procentenheter jämfört med kmom06 (tack vare att jag testat det mesta av koden i projektet).

En del rättningsinställningar har jag ändrat. Den mest betydelsefulla är att jag exkluderat StaticAccess-regeln från phpmd. Jag tänker inte argumentera med phpmd: Att undvika static access ”till varje pris” låter lite väl hårt men efter att har läst om det på deras hemsida förstår jag att det kan göra det svårt att testa koden bland annat. Klasserna det gäller lagrar inget state och har bara enstaka eller inga dependencies alls. Så min bedömning är att det helt enkelt inte är något jag behöver ändra så här sent i projektet (jag körde inte phpmd förrän jag var klar med spelet). Till nästa gång ska jag däremot ha det här i åtanke redan från början.


## Krav 4: JSON API
Totalt har jag gjort 7 router. Två är POST: Man kan ansluta två rum i en viss riktning genom att skapa en ny connection och man kan återställa databasen. Resten är GET: Man kan hämta alla föremål eller rum i spelet, samt ett specifikt föremål eller rum, och man kan hämta loggmeddelandena som just nu finns i sessionen. För att ansluta två rum fyller man i ett formulär som finns på API-sidan. Routerna för att hämta alla eller bara enstaka föremål respektive rum har en knapp var. Knappen hämtar alla föremål respektive rum, men man kan ändra URL:en manuellt enligt beskrivningen på API-sidan för att hämta ett specifikt föremål eller rum. Routerna för att hämta loggen och återställa databasen har också varsin knapp.

Målet har varit att implementera bättre felhantering än tidigare och att testa alla router i API:et. För att göra koden mera testbar har jag angett en statuskod i varje JSON-respons som man kan verifiera i testerna. Även dåliga requests ger en JSON-respons med ett meddelande och en statuskod, och får alltså inte programmet att krascha. I testerna använder jag en testdatabas med fixtures. Vilket jag tar upp som en extragrej i krav 6.
## Krav 5: ORM

### Inledning
Som namnet antyder innefattar ett textbaserat spel just en massa text. För att skriva och organisera alla namn och beskrivningar på saker i spelet har jag använt kalkylark. Ganska tidigt slog tanken mig att det hade varit smidigt om man kunde importera all data i form av CSV-filer till databasen, ungefär på samma sätt som vi gjorde i databaskursen. Det skulle också ge ett enkelt sätt att återställa databasen genom att först droppa den, återskapa schemat och sedan läsa in filerna igen. Så jag bestämde mig för att göra just detta.

### Teknisk info
Jag har använt mig av SQLite och skapade en ny databas för projektet. I databasen finns åtminstone en tabell för varje slags klass i spelet (Location, Item, Action och Response) plus en kopplingstabell (Connection) för att koppla ihop rummen. Totalt sett är det alltså fem tabeller. Det finns även en testdatabas, men mer om det i krav 6.

### Samband
Istället för att referera direkt till ett annat entitetsobjekt har jag löst samband mellan entiteter genom att använda främmande nycklar. Vilket fungerar alldeles utmärkt, fast jag vet att man inte borde göra så. Dessa främmande nycklar har egentligen ingen betydelse i och med att vi befinner oss i objektlagret ovanpå relationsdatabasen. Det medför inga constraints och gör inte heller att man på ett enkelt sätt kan kan hämta objekt som hör ihop (men man hade kunnat skapa egna queries för det om man vill). Det mest korrekta hade varit att referera direkt till en annan entitet och låta Doctrine hantera sambandet i databasen. 

Varför blev det så här? Det går som exempel inte att lagra ett helt objekt i ett fält i ett kalkylark eller i en CSV-fil, utan man är begränsad till främmande nycklar och att skapa eventuella kopplingstabeller manuellt. Låt oss ta sambandet mellan rum som ett exempel. Här har vi att göra med ett självrefererande många-till-många-samband (vilket stöds av Doctrine). Jag skulle behöva läsa in CSV-filerna för rummen och kopplingstabellen och sedan använda någon slags mappning i koden för att få ihop det. Och här kommer vi in på nästa anledning. Nämligen att jag ändå kommer att behöva mappa entiteterna till objekt i spelet och då använda främmande nycklar för att bygga arrayer och hitta rätt index! Att har riktiga samband som låter mig hämta objekt som hör ihop skulle inte vara till speciellt stor hjälp i det här syftet. Och det här syftet är trots allt det som spelar roll.

Enligt mig har jag löst sambanden på ett okej sätt utifrån hur jag valde att gå till väga. Men ännu bättre hade kanske varit att lägga upp det annorlunda från början och lagra något helt annat i databasen. Något som lämpar sig bättre för att skapa samband det vill säga. Ett exempel hade varit att göra det möjligt för spelaren att spara spelet. Eftersom spelet är så pass enkelt uppbyggt hade det förmodligen räckt om man lagrade alla spelarens kommandon som en sträng ihop och en referens till spelarens rad i en ”användare”-tabell där man har användarnamn och lösenord till exempel. När man vill starta ett sparat spel matar man in kommandona ett i taget och låter datorn spela fram till det ställe där spelaren var innan. På så vis skulle även loggen återskapas. Jag var faktiskt påväg att göra det här, och det är därför det finns en metod i logklassen som gör att man kan dumpa loggen till en sträng.

### Jämföra ORM
En Object-Relational Mappar är ett lager till ovanpå databasen som gör att man kan jobba mot entiteteterna som om de var objekt i det programmeringsspråk man använder. Sitter man i en miljö där man själv eller andra använder en objektmodell finns det alltså uppenbara fördelar. Ska sägas att jag jämför ORM med att skapa queries med SQL direkt, som vi gjorde i databaskursen.

Nu har vi använt Doctrine ORM, så jag kommer i första hand att utgå från det (antagligen fungerar ORM av andra leverantörer i andra programmeringsspråk på ett liknade sätt). I Doctrine kommer ORM ihop med DBAL, ett lager av abstraktion som bland annat innehåller drivers för ett flertal relationsdatabasleverantörer och som gör att koden man skriver översätts till rätt leverantörs språk i databasen.

Det har mycket riktigt blivit mindre SQL nu än i databaskursen.    Jag har bara använt det i ett par metoder i repositorierna och för att köra enkla queries direkt i terminalen för att fort läsa i databaserna. Det har känts ovant att inte ha lika stor insyn i vad som försegår bakom koden. Men jag uppskattar hur lätt det är att använda Doctrine ORM när man väl kommit in i det. Man använder rader i tabellerna som om de var vilka andra objekt som helst, flushar och låter Doctrine hantera exekveringen av all nödvändig SQL på det mest effektiva sättet. Är man väl förtrogen med SQL kan man säkert överträffa Doctrine, speciellt om man har specifika krav. Men så är det knappast i mitt fall.

Hur Doctrine lägger upp det hela med repositorier, och entitetsklasser gör dessutom att man får en bra struktur i koden. Med hjälp av entitymanagern når man ORM-funktionaliteten överallt, oavsett om man kodar en kontroller, ett kommando eller ett test. Det kan ta en stund att vänja sig vid, men när man väl gör det är det här ett smidigt sätt att jobba på. Även här vill jag dock lägga in en passus. Vill man har större kontroll eller har man specifika krav kan det säkert vara värt att lösa strukturen på egen hand genom att koda på ”en lägre nivå”, ungefär som vi gjorde i databaskursen där vi installerade en MySQL-driver i Node och skrev alla queries själva och skapade funktioner för att exekvera dem i koden.

### Databastester med Scrutinizer
Jag märkte direkt att flera tester inte gick igenom när Scrutinizer körde dem (fast de fungerade lokalt). Ett tydligt mönster var att alla tester som använde en databas inte fungerade. Värt att påpeka är att testerna av klassen som sätter up spelet från en databas fungerar. Här använder jag dock varken den riktiga databasen eller testdatabasen i testerna: Jag mockar bara repositoryklasserna med exempeldata ungefär som i ett vanligt enhetstest.

Problemet var att inga tabeller gick att hitta. För att ta reda på vad problemet berodde på lade jag till debugutskrifter in testerna. Enligt utskrifterna var SQLite versionen annorlunda, fast inte så mycket att det kunde vara orsaken. Båda mina databaser fanns i Doctrine. Men mycket riktigt dök det inte upp några tabeller alls när utskrifterna gjordes i Scrutinizer. Jag bör kanske nämna att jag innan debuggandet gjorde några halvhjärtade försök att ändra miljövariabler i configfilen samt att köra phpunit kommandot med olika options. Det blev dock uppenbart att Scrutinizer har en egen miljö. Efter debuggandet kom jag fram till att jag nog behövde tala om för Scrutinizer att skapa tabellerna och fylla dem med data.

Som tur var hade jag ett färdigt sätt att göra det på, nämligen ett kommando för att återställa speldatabasen. Jag lade till kommandot i configfilen och voilá! Sedan testade jag att även läsa in mina fixtures. Vilket också fungerade och jag kunde därmed använda dem i alla tester som det var tänkt från början.

I slutändan blev det bara ett par saker jag ändrade i själva testerna. Jag valde att skippa ett test av en kontroller där statuskoden blev annorlunda i Scrutinizer jämfört med lokalt (samma problem uppstod när vi testade våra kortspel). Jag fick också justera ett testfall där jag jämför outputen från ett kommande med det jag förväntar mig. Av någon anledning lägger Scrutinizer in en radbrytning mitt i just den här outputen. Andra liknande tester fungerar likadant både i Scrutinizer och lokalt. Kanske var outputen för lång. I vilket fall som helst använder jag nu ett regular expression för att ta bort extra mellanrum i outputen.


## Krav 6: Avancerade features

### Inledning
Jag har fått fundera lite på vad det innebär med avancerade features. Det jag valt att gå på är saker som jag anser är utanför baskraven eller som vi inte gått igenom tillsammans i kursen. För att lösa samtliga features har jag behövts läsa på och testa mig fram till en lösning.

### Feature 1: Databastestning
Det första jag testade som hade med databasen att göra var klassen som sätter upp spelet. Här valde jag att mocka repositoryklasserna med exempeldata. Det kändes mest likt hur vi jobbat med tester innan. Sedan bestämde jag mig för att även testa kommandot som läser in CSV-filer i databasen. Då insåg jag att det var läge att sätta upp en ren testdatabas för att slippa mixtra med den riktiga. Testdatabasen fick jag också användning för när det blev dags att testa JSON API:et. Då skapade jag fixtures för att på ett kontrollerat och förutsägbart sätt testa de olika routerna. Till den här featuren kan vi också räkna att få testerna att fungera i Scrutinizer.

### Feature  2: Kommandon
För att läsa in CSV-filer och återställa databasen skapade jag kommandon. Kommandon dök upp som ett alternativ när vi jobbade med databaser i ett tidigare kursmoment fast det var inget vi gick igenom tillsammans. Nu kände jag att det fanns tid i att sätta mig in i hur man gör. Grunde gick fort. Det finns tydliga exempel i Symfonys guide på hur man gör. Utmaningen var att kunna läsa in CSV-filer på ett generellt sätt. Det innefattade flera steg, från att hantera filer och strängar till entiteter i databasen. I kommandot för återställning av databasen hårdkokade jag det mesta och det blev därför lite enklare. En stor fördel med kommandon är att de både går att köra direkt i terminalen, vilket är praktiskt när man utvecklar, och inuti en kontroller. Kommandot för återställning av databasen använder jag som exempel också i JSON API:et. Kommandot för att läsa in CSV-filer valde jag att testa. Vilket också kan räknas in i den här featuren.

### Feature 3: Användarvänligt gränssnitt i spelet
Den här featuren har involverat HTML, Twig och CSS samt Javascript och PHP. Man skulle kunna dela up det i ett par minifeatures. Allt kretsar kring det terminalliknande fönstret där spelaren kan se loggen och mata in kommandon. En sådan minifeature är att spelaren kan bläddra igenom gamla kommandon med piltangenterna. I bakgrunden använder jag en logg där endast spelarens kommandon sparas. De loggade kommandona skickas med till templatefilen som ett dataattribut i ett element så att jag kan  hämta dem med Javascript. En annan minifeature har att göra med utseendet på fönstret. Med hjälp av CSS highlightar jag spelarens senaste input och gör det tydligt vilken respons som är aktuell. Med hjälp av ett trick där man använder två element med flex, varav det yttre flexar i omvänd riktning, har jag gjort så att fönstret är scrollat längst ner i utgångsläget. På så vis ser man alltid vad som är mest aktuellt först. Vill man kan man scrolla upp och se hela historiken. En tredje liten feature är att formatera utskriften av hjälpkommandot som en tabell, vilket jag skapade en separata klass till. Ingen av dessa minifeatures har krävt varken mycket eller speciellt svår kod. Men de har krävt lite designtänk och är helt klart extra. 

## Om projektet

Projektet har gått bra att genomföra. Det känns alldeles rimligt utifrån det vi gått  igenom i kursen. Hur lång tid det tar beror väl på vilken ambitionsnivå man har, alltså vilket fokus man väljer, hur många av kraven man gör och till vilken nivå, hur hård man är i rättningen samt hur mycket man lägger på sidans utseende. Vill man så går det att bli klar inom 20-40 timmar. I skrivande stund är det drygt en och en halv månad sedan jag påbörjade projektet. Vissa dagar har jag lagt någon timme här och någon timme där, vissa dagar har jag inte gjort något alls. Så det är svårt för mig att säga exakt hur lång tid det  har tagit. Mer än 40 timmar är det dock säkert.

## Om kursen

Kursen som helhet har varit mycket bra. Fast de olika momenten  varit rätt annorlunda har det hela tiden funnits en röd tråd, nämligen att skriva bra objektorienterad kod.

Jag önskar att vi hade kunnat dyka djupare ner i de olika momenten. Det blir också mitt förslag till framtida kurstillfällen. Ett exempel är att göra mer testning tillsammans så att man kan se hur ni lärare löser svårare fall, inte minst vad gäller databastestning och testning av kontrollerklasser. För att få tid till det behöver man kanske ta bort något annat. Det blir dessutom mycket ställtid när varje moment är något nytt som behöver installeras och sättas upp. Men det finns visserligen en vits med att göra sådant också.

I oopython gick Andreas igenom inlämningar och gav konstruktiv kritik på stream. Det hade varit kul med något liknande i den här kursen där ni går igenom inlämningar (anonymt såklart) och snyggar till koden. Det behöver inte ens vara en stream utan kan vara förinspelat och helt frivilligt att kolla på för de som är intresserade.

Som vanligt har det gått fort att få svar via Discord. För den som är intresserad är det här helt klart en kurs jag skulle rekommendera.  Visst har det funnits stunder när man sliter sig i håret. Men det är väl programmerarens lott. En tia från mig och varma sommarhälsningar till er alla. Vi ses i höst!
