{% extends "proj/base.html.twig" %}

{% block title %}About Database{% endblock %}

{% block body %}
<div class="window">
    <div class="window-heading">
        <span>About Database</span>
    </div>
    <div class="window-body flex flex-col gap-lg overflow-auto article">
        <h1>Inledning</h1>
        <p>För att skriva och organisera alla namn och beskrivningar på saker i spelet har jag använt kalkylark. Ganska tidigt slog tanken mig att det hade varit smidigt om man kunde importera all data i form av CSV-filer till databasen, ungefär på samma sätt som vi gjorde i databaskursen. Det skulle också ge ett enkelt sätt att återställa databasen genom att först droppa den, återskapa schemat och sedan läsa in filerna igen. Så jag bestämde mig för att göra just detta. Lösningen blev ett kommando för att läsa in CSV-filer.</p>

        <h1>Teknisk info</h1>
        <p>Jag har använt mig av SQLite och skapade en ny databas för projektet. I databasen finns åtminstone en tabell för varje slags klass i spelet (Location, Item, Action och Response) plus en kopplingstabell (Connection) för att koppla ihop rummen. Totalt sett är det alltså fem tabeller.</p>
        <ul class="pretty-ul">
            <li>Location: Som jag kommer att kalla "rum" på svenska. Har ett namn (name) som inte visas i spelet. Istället visas en kort beskrivning (description) eller en lång, detaljerad beskrivning (details) beroende på om spelaren är i ett intilligande rum eller går in i rummet.</li>
            <li>Item: Har ett namn (name) som däremot visas i spelet. Namnet är ett enda substantiv och det är genom det här namnet som spelaren kan interagera med föremålet. Föremålet har också en beskrivning (description) som visas upp när spelaren kommer in i rummet där föremålet finns. Vilket rum det finns i bestäms av rum-id:t (location_id)</li>
            <li>Action: Har ett föremåls-id (item_id) som talar om vilket föremål det hör till. Typen (type) används för att mappa det till en av de tre olika typerna av actions i spelet ("examine", "take" eller "use"). En del actions kräver att spelaren befinner sig i ett visst rum (required_location_id).</li>
            <li>Response: En action kan ha en respons. Vilken action som en respons hör till bestämms av action-id:t (action_id). I nuläget är det bara "use"-actions som har det. Responsen triggas när föremålet med en "use"-action används. Responsen innehåller ett rum kan man säga (via location_id). Antingen flyttas spelaren till det rummet eller så byts spelarens nuvarande rum ut om det rummet.</li>
            <li>Connection: Är en kopplingstabell mellan rum. Det finns med andra ord två rum-id:n (from_location_id och to_location_id). Varje koppling har också en riktning (direction), vilket är namnet på ett av de fyra väderstrecken. Det här namnet används i spelet för att kunna navigera mellan rum.</li>
            </ul>

        <h1>ER-diagram</h1>
        <p>Här är ett enkelt ER-diagram med kardinalitet. Pilarna är endast till som ett visuellt stöd för att tala om åt vilket håll man bäst utläser de olika sambanden.</p>
        <div class="embed-container">
            <iframe title="Simple ER diagram with cardinality" frameborder="0" src="https://viewer.diagrams.net/?tags=%7B%7D&amp;highlight=FFFFFF&amp;layers=1&amp;nav=1&amp;title=proj.drawio#R5Vzfc6I6FP5rfOwdkgDqoz%2Fa3Z3Z3um0M3u3jyykmrlI3BCr7l%2B%2FiQSFRCtFBZSnwkk4hPN9Ock5J7aDRrPVF%2BbNp480wGEHWsGqg8YdCAEAtvgjJetE4kI3EUwYCVSnneCF%2FMFKaCnpggQ4znXklIaczPNCn0YR9nlO5jFGl%2FlubzTMv3XuTbAhePG90JT%2BRwI%2BTaQ92N3Jv2IymaZvBm4%2FaZl5aWf1JfHUC%2BgyI0L3HTRilPLkarYa4VAaL7VL8tzDgdbtwBiOeJEH4te7Z%2F%2Fbj%2Bj5dzB9Yhx8Z3ePd7Ya3LsXLtQXq9HydWoCMfC5vHwL8WogTdpBQxwF6nLsh14cE18Ip3wWCgEQl4wuogDLN1vi7o2E4YiGlG0UInA%2F6j4MhHzCvICI4WfaHqz7wXgs2mLO6P84bYloJIYwpHPPJ1xSybW2fVJc7IzGMWGCDYRGQr7EsTDQ0LSXMmFMF8zHHxgp5Z3HJph%2F0A8l%2FXCQo5RC4wumM8zZWnRY7ojkKPtPMxxKZQyHHifveSJ6is%2BTrbrtG54oEV8GLTX3YFfpUTPPSadUqiL5bvVUljhHFCFdUWIYQ5G4yHz2TrTh5Sc4ivq3xdGDRDxKMNAogjlOnhd2vyzBXI1gVsUE690WwfY5Qeyd6ATtghx1GsVReC6O2hpHt%2BSviqPd2%2BdoRJlsP4GkqCBJ7UaR1NW4ZfdKklRXBHVFlyYpui2Slieic5UrOkDaQmz3yhER9DQi9jVFFyYiMHj4nfrexs3ofFxOCccvggnyfimC2Dz1vJBMpG%2FyBQUw%2B4gT75hxvPoQxUPWSc2eQRlYe2C2rcOI5kz4WXtBw16jJJ4Wk04G3AdnMZvS2a%2BFGM5wjhkRg5E2SqVPO9GwDjNrccvWpFkzwz1mdi9lZtM9fuN41gRKOlbTKGkbthr4TZnAurXsbt3WcgxrPeN4TqMYN8FeusOr316uYa%2Bv4h3X6OWQtmZv8421ebkCkUpmw6f2Ygd3e3hF%2BE%2FVIq9fpfwfR92NV5lu47W6OWjWo%2Fs2NdSz7dtO3ZABbQnrlowM9ByeoejCG7ICGZYSnLA%2BwQlBBbb%2Buesob1%2BzbbvHNnc3xyXNB4OyQebWKR9SdGEqFcgGN9a9FE30uhW5l34eSiOzX5QTyDmi6NLxXoEyVmNJ4RYkRdHy0omkQPBMpLB7NZPCjGpPIcUJs74owkXTkqcirIcvpRHWE5dVI1wg31gNwkWrIxUh7GpzGJYte3SNRF7FCJuBbT0IF60sgIoQ1ouvsGxkYFRxUcUIm4meaw3FbX07le6UawvFwXlj8fLTp3A9pKKdrx4Nla4LG6nAqh3k7WaytruL%2BqaPmbYAhmnF1%2FEjxpE2IL4XDlTDjASBfHzIcEz%2BeL82quQEm0uabL7CGXYcWbj0FpzGyalIcKiOmS2IKtEZ4HCMOKBnwIH2oKGvH%2BdDw4z8H9uDhn5GqlczGik7Mmj82xo0gIbGvtJitWiYFe%2F2zA3YdRqGhpl5aM%2B6gWAeDVj3ugHNLEF75oatZwJqR6MpET1sWM7GKOSWPqraP6LowiEJbErQWbTaAitCGDrdPDClczapS9PPU1SFsJmzeca%2FF0Q4QgPpa4w860%2FcwDZHnqjfz8NRe6xjRp4tQsPJ7%2BdqzwMgM%2FJMDrsF8WZUYlDX6IT046r1OyFkBpX1LOQp4mf78dGp5yb0pK9%2BTrHsL98MRZf%2BwYaZPW44whUdltI3BLAkwMYJG13RhQG2zdi3PSuXHvvuKyhUunLZ5r65PWgUKe9Ui4aZiWgPGmJbl3dMde%2BxbXMpag8aoF%2FZHlvc7v7nSLLM7P5zC7r%2FCw%3D%3D"></iframe>
        </div>
        <p>I det här diagrammet har jag lagt till de olika attributen som tabellerna har och anpassat typerna på attributen till SQLite. Jag använder termen foreign key (FK), men i själva verket finns det inga sådana starka samband i databasen. För mer information läs avsnittet om samband.</p>
        <div class="embed-container">
            <iframe title="ER diagram with foreign keys, fields and field types" frameborder="0" src="https://viewer.diagrams.net/?tags=%7B%7D&amp;highlight=FFFFFF&amp;layers=1&amp;nav=1&amp;title=proj.drawio#R7V1tc6I6GP01ztz7oTsCxbYf1bb7Utvt7O69nbtfOilEzSwSNqRW99ffRAJWExFEFAkznV0JMcBzTk7Ccwi2rP5k9pGAYHyPXei1zLY7a1nXLdM0rjrn7D9eMo9KOmYnKhgR5IpKy4Lv6A8UhW1R%2BopcGK5UpBh7FAWrhQ72fejQlTJACH5brTbE3upRAzCCUsF3B3hy6RNy6TgqvbTby%2FJPEI3G8ZGNttgzAXFlURCOgYvfVorgjN5in4pTfIRkAnzoU7bnHpBfkLTsmzGl%2FEq7LfOW%2FQ157Q8jjEceBAEKPzh4woqdkFW5HYIJ8niY3zXUEw2xw1k3LatPMKbRp8msDz2OVQxDdE63G%2FYmcSC83Qxf6J9N54Nfbep%2FerP%2Bpff3o8eLlzMzamUKvFcR388UTkR86DwOOgtVwD9S8MKLeiEFhApuWG1WwNCmAPnswqxrY7HteSAI0aJ6VDJGnjsAc%2FxK44bird4QzaD7LaIGr8tYMmCN8U3eOA%2Fyd3EyfDfw0Mhnnx125fyIPQJDdi4DEFJRQ46NCNcUEgpn74pErD5CPIGUzFkVsfc8ZpToJ0bMkbcl68y4zvg94%2BJCIGg0StpeosM%2BCIBygGVJYG0Eil06RcD7xnog8EcLzFYh4XF1CQ5%2BADKCVBQEGPGI3kxh1AcWwUee18ce5sj62IdxtcXF2T32xy633%2F5gt2x2An22bSy32R%2BvTmgf%2ByEljCH8UJAB9QY5WD2KA3EcDw7j0yAimPzzC6aUdalNsKaSejvWAlsrI7RWWcieS8g%2B3uXBFrNrHXoLMRsj14V%2B1CW5AIMl3goolfFPYr4OxnpHzIiHlRmPdwBYOeMvGltGJXdrwGPc9wGFPfzqu6EEanKeu%2BNsSziz6n2z1W2jxSjz8PUH%2F%2FefwaCVjFJVIkCsvFHdXhgAB%2FmjQfTNzhpD7DIYMtvcY829MiZTcwegTEdn0W%2BXKPqdY4v%2BhYTs7Z1RwU6fEYBOZgDqrvKXErAedgBF2H9m3zMVWl85zLcK%2Fd5JoZ2wXzXCXo6wXx1b2ONUyY7QVkvWrzKHv%2B6ybhgSrD6YwEUJccaA%2FGXa9t%2B6KHt2XtRZ2edf0H83D6TLVNZ6uP7iPP2cXp9ZMlEaad%2BLtGdOwu1D29XYyhnTCnZyOf7pRNVK3NWhkJOrLgwdggI%2Bb2c7HA%2B%2F1FDbi%2FKizuKungXIROk6EUca02TdNLEuspomndIm43JuXaPBOEeW3siehK2KbWLI%2BfQ6%2BSYJdbUantWhkNPgG1JpOtkmOQii3zgtp9c10v0cN2H5df%2FozokhZ9hP2jpJuNoIvSGnxRGFE%2B2MkxyUqLO0Pzx8fDbufoTmw1Nn%2Bss4%2Fz19%2Ftk4J6Up%2ByGtEyW0Cuvk9u40MmypVNVK2NXIyklxAn%2B%2FIgLdZ4U9XjnAdxD2goyos66r7YBivmkj7BUxTtTgFjPFqjVhT5iqla6rQ2FKuNJ58N4VN9ramOI5eKGfusvGyUCM%2BxsZoZF1kih0ddabmI11krHbn551YtbbOjEb6yQJRWOdFCOIfiN1Y52UpftHt05M2TqpYK%2FPGv%2FGN0lCISfFNX44OQcx6qzuyof7mixbaep%2BSPtEje2JJtnSiaqVuqtDISfZ9H06uUmypcRG63eElCrux197UjAfVzF11%2FKtIOpQyLk4F1KAvFA3ZW%2FeA7IxNvLM7hsMAyaZcCMhNHZPrEs7m1gb5am1ziOxGtZUYlfSO1Evj5OQPVHrJJW3zbgsT7f0Mk4K0kO7IVqexmmk%2BDmm%2FrkV%2F5CuifKMZQv1VNabpBK1kXjZ6QRO3V%2FUVZAS2sl6Mce0kfXq2iWyZ3oqi01SidrIumIZkQ6vYCzICu2UXbEmqR8B2TyUvNh7lvzsw1GeSlaD1iTWMo7Hp5dZU7xcqU6ptYS6zQiteC1Tk1zLQxD9BusmvVaW7h89v6Z4vdNJJ9iMJsOWhEJOsQ0JnqjW%2FOtxP5aDG3XWePVLIhqJL0nij%2F5mF%2Fmu7VRybalM1UrglZGQb9ko1kLdC%2FJCO3HXejV5qeJ%2B0EeTldgWuzerlrRruXRcGQn5rsxFJM6O1%2Fz9LgWpoZ26Z3DJoe92%2BS9AL1Ec0wk7iLA72JlBd2NXjbMB%2BJU4or3UhR00Hhk2VozqQXfl96ZlJAn02FRmCldOIwWnRxxNdwQDkpn3XA1NdEHiS0tYpHakV%2BuvtRNdr9TO3u7M5Pl7xfGNvYSyAbbaa8AYuyLc2dJQ2RBnWDt2GIgrhrAtdb0dEb4wtjS0P4S%2F9j%2FfdcfXb26Iw673ZPV61tcs6ZV9A5w6w92u0YdCeBUX29wR4HW7XGqoZICrItKGQqTTnhkrXaPXpNU%2B3xFg29zSUMkAV0aiKwawuYbL%2BcWOAFuXWxraGWC2STCm76sTEIzvsQt5jf8B"></iframe>
        </div>
        <h1></h1>
        <h1>Samband</h1>
        <p>Istället för att referera direkt till ett annat entitetsobjekt har jag löst samband mellan entiteter genom att använda främmande nycklar. Vilket fungerar alldeles utmärkt, fast jag vet att man inte borde göra så. Dessa främmande nycklar har egentligen ingen betydelse i och med att vi befinner oss i objektlagret ovanpå relationsdatabasen. Det medför inga constraints och gör inte heller att man på ett enkelt sätt kan kan hämta objekt som hör ihop (men man hade kunnat skapa egna queries för det om man vill). Det mest korrekta hade varit att referera direkt till en annan entitet och låta Doctrine hantera sambandet i databasen.</p>
            
        <p>Varför blev det så här? Det går som exempel inte att lagra ett helt objekt i ett fält i ett kalkylark eller i en CSV-fil, utan man är begränsad till främmande nycklar och att skapa eventuella kopplingstabeller manuellt. Låt oss ta sambandet mellan rum som ett exempel. Här har vi att göra med ett självrefererande många-till-många-samband (vilket stöds av Doctrine). Jag skulle behöva läsa in CSV-filerna för rummen och kopplingstabellen och sedan använda någon slags mappning i koden för att få ihop det. Och här kommer vi in på nästa anledning. Nämligen att jag ändå kommer att behöva mappa entiteterna till objekt i spelet och då använda främmande nycklar för att bygga arrayer och hitta rätt index! Att har riktiga samband som låter mig hämta objekt som hör ihop skulle inte vara till speciellt stor hjälp i det här syftet. Och det här syftet är trots allt det som spelar roll.</p>

        <h1>Testning av databasen</h1>
        <p>Det första jag testade som hade med databasen att göra var klassen som sätter upp spelet. Här valde jag att mocka repositoryklasserna med exempeldata. Det kändes mest likt hur vi jobbat med tester innan. Sedan bestämde jag mig för att även testa kommandot som läser in CSV-filer i databasen. Då insåg jag att det var läge att sätta upp en ren testdatabas för att slippa mixtra med den riktiga. Testdatabasen fick jag också användning för när det blev dags att testa JSON API:et. Då skapade jag fixtures för att på ett kontrollerat och förutsägbart sätt testa de olika routerna.</p>

        <h1>Databastester i Scrutinizer</h1>
        <p>Jag märkte direkt att flera tester inte gick igenom när Scrutinizer körde dem (fast de fungerade lokalt). Värt att påpeka är att testerna av klassen som sätter up spelet från en databas fungerar. Här använder jag som sagt dock varken den riktiga databasen eller testdatabasen i testerna: Jag mockar bara repositoryklasserna med exempeldata ungefär som i ett vanligt enhetstest.</p>
            
        <p>Problemet var att inga tabeller gick att hitta. För att ta reda på vad problemet berodde på lade jag till debugutskrifter in testerna. Enligt utskrifterna var SQLite versionen annorlunda, fast inte så mycket att det kunde vara orsaken. Båda mina databaser fanns i Doctrine. Men mycket riktigt dök det inte upp några tabeller alls när utskrifterna gjordes i Scrutinizer. Jag bör kanske nämna att jag innan debuggandet gjorde några halvhjärtade försök att ändra miljövariabler i configfilen samt att köra phpunit kommandot med olika options. Det blev dock uppenbart att Scrutinizer har en egen miljö. Efter debuggandet kom jag fram till att jag nog behövde tala om för Scrutinizer att skapa tabellerna och fylla dem med data.</p>
            
        <p>Som tur var hade jag ett färdigt sätt att göra det på, nämligen ett annat kommando! Det här kommandot återställer speldatabasen. Jag lade till kommandot i configfilen och voilá! Sedan testade jag att även läsa in mina fixtures. Vilket också fungerade och jag kunde därmed använda dem i alla tester som det var tänkt från början.</p>
    </div>
</div>
{% endblock %}
